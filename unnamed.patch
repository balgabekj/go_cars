Index: cmd/carHandler.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/carHandler.go b/cmd/carHandler.go
--- a/cmd/carHandler.go	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ b/cmd/carHandler.go	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
@@ -3,6 +3,7 @@
 import (
 	"database/sql"
 	"encoding/json"
+	"errors"
 	"github.com/balgabekj/go_car/pkg/model"
 	"github.com/balgabekj/go_car/pkg/validator"
 	"github.com/gorilla/mux"
@@ -125,13 +126,17 @@
 	// Delete car from the database
 	err := app.models.Cars.Delete(id)
 	if err != nil {
-		app.models.Cars.ErrorLog.Println(err)
-		http.Error(w, "Error deleting car", http.StatusInternalServerError)
+		switch {
+		case errors.Is(err, model.ErrRecordNotFound):
+			app.notFoundResponse(w, r)
+		default:
+			app.serverErrorResponse(w, r, err)
+		}
 		return
 	}
 
 	// Return success response
-	w.WriteHeader(http.StatusNoContent)
+	app.writeJSON(w, http.StatusOK, envelope{"message": "success"}, nil)
 }
 
 func (app *application) respondWithError(w http.ResponseWriter, code int, message string) {
Index: cmd/helpers.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/helpers.go b/cmd/helpers.go
--- a/cmd/helpers.go	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ b/cmd/helpers.go	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
@@ -25,8 +25,6 @@
 	return id, nil
 }
 
-// writeJSON marshals data structure to encoded JSON response. It returns an error if there are
-// any issues, else error is nil.
 func (app *application) writeJSON(w http.ResponseWriter, status int, data envelope,
 	headers http.Header) error {
 	// Use the json.MarshalIndent() function so that whitespace is added to the encoded JSON. Use
@@ -37,11 +35,6 @@
 	}
 	// Append a newline to make it easier to view in terminal applications.
 	js = append(js, '\n')
-	// At this point, we know that we won't encounter any more errors before writing the response,
-	// so it's safe to add any headers that we want to include. We loop through the header map
-	// and add each header to the http.ResponseWriter header map. Note that it's OK if the
-	// provided header map is nil. Go doesn't through an error if you try to range over (
-	// or generally, read from) a nil map
 	for key, value := range headers {
 		w.Header()[key] = value
 	}
@@ -55,94 +48,6 @@
 	return nil
 }
 
-//
-//// readJSON decodes request Body into corresponding Go type. It triages for any potential errors
-//// and returns corresponding appropriate errors.
-//func (app *application) readJSON(w http.ResponseWriter, r *http.Request, dst interface{}) error {
-//	// Use http.MaxBytesReader() to limit the size of the request body to 1MB to prevent
-//	// any potential nefarious DoS attacks.
-//	maxBytes := 1_048_576
-//	r.Body = http.MaxBytesReader(w, r.Body, int64(maxBytes))
-//	// Initialize the json.Decoder, and call the DisallowUnknownFields() method on it
-//	// before decoding. So, if the JSON from the client includes any field which
-//	// cannot be mapped to the target destination, the decoder will return an error
-//	// instead of just ignoring the field.
-//	dec := json.NewDecoder(r.Body)
-//	dec.DisallowUnknownFields()
-//	// Decode the request body to the destination.
-//	err := dec.Decode(dst)
-//	if err != nil {
-//		// If there is an error during decoding, start the error triage...
-//		var syntaxError *json.SyntaxError
-//		var unmarshalTypeError *json.UnmarshalTypeError
-//		var invalidUnmarshalError *json.InvalidUnmarshalError
-//		switch {
-//		// Use the error.As() function to check whether the error has the type *json.SyntaxError.
-//		// If it does, then return a plain-english error message which includes the location
-//		// of the problem.
-//		case errors.As(err, &syntaxError):
-//			return fmt.Errorf("body contains badly-formed JSON at (charcter %d)", syntaxError.Offset)
-//		// In some circumstances Decode() may also return an io.ErrUnexpectedEOF error
-//		// for syntax error in the JSON. So, we check for this using errors.Is() and return
-//		// a generic error message. There is an open issue regarding this at
-//		// https://github.com/golang/go/issues/25956
-//		case errors.Is(err, io.ErrUnexpectedEOF):
-//			return errors.New("body contains badly-formed JSON")
-//		// Likewise, catch any *json.UnmarshalTypeError errors.
-//		// These occur when the JSON value is the wrong type for the target destination.
-//		// If the error relates to a specific field, then we include that in our error message
-//		// to make it easier for the client to debug.
-//		case errors.As(err, &unmarshalTypeError):
-//			if unmarshalTypeError.Field != "" {
-//				return fmt.Errorf("body contains incorrect JSON type for field %q",
-//					unmarshalTypeError.Field)
-//			}
-//			return fmt.Errorf("body contains incorrect JSON type (at character %d)",
-//				unmarshalTypeError.Offset)
-//		// An io.EOF error will be returned by Decode() if the request body is empty. We check
-//		// for this with errors.Is() and return a plain-english error message instead.
-//		case errors.Is(err, io.EOF):
-//			return errors.New("body must not be empty")
-//		// If the JSON contains a field which cannot be mapped to the target destination
-//		// then Decode() will now return an error message in the format "json: unknown
-//		// field "<name>"". We check for this, extract the field name from the error,
-//		// and interpolate it into our custom error message.
-//		// Note, that there's an open issue at https://github.com/golang/go/issues/29035
-//		// regarding turning this into a distinct error type in the future.
-//		case strings.HasPrefix(err.Error(), "json: unknown field "):
-//			fieldName := strings.TrimPrefix(err.Error(), "json: unknown field ")
-//			return fmt.Errorf("body contains unknown key %s", fieldName)
-//		// If the request body exceeds 1MB in size then decode will now fail with the
-//		// error "http: request body too large". There is an open issue about turning
-//		// this into a distinct error type at https://github.com/golang/go/issues/30715.
-//		case err.Error() == "http: request body too large":
-//			return fmt.Errorf("body must not be larger than %d bytes", maxBytes)
-//		// A json.InvalidUnmarshalError error will be returned if we pass a non-nil
-//		// pointer to Decode(). We catch this and panic, rather than returning an error
-//		// to our handler. At the end of this chapter we'll talk about panicking
-//		// versus returning, and discuss why it's an appropriate thing to do in this specific
-//		// situation.
-//		case errors.As(err, &invalidUnmarshalError):
-//			panic(err)
-//		// For anything else, return the error message as-is.
-//		default:
-//			return err
-//		}
-//	}
-//	// Call Decode() again, using a pointer to an empty anonymous struct as the
-//	// destination. If the request body only contained a single JSON value then this will
-//	// return an io.EOF error. So if we get anything else, we know that there is
-//	// additional data in the request body, and we return our own custom error message.
-//	err = dec.Decode(&struct{}{})
-//	if err != io.EOF {
-//		return errors.New("body must only contain a single JSON value")
-//	}
-//	return nil
-//}
-
-// readString is a helper method on application type that returns a string value from the URL query
-// readStrings is a helper method on application type that returns a string value from the URL query
-// string, or the provided default value if no matching key is found.
 func (app *application) readStrings(qs url.Values, key string, defaultValue string) string {
 	// Extract the value for a given key from the URL query string.
 	// If no key exists this will return an empty string "".
@@ -154,11 +59,6 @@
 	// Otherwise, return the string
 	return s
 }
-
-// readInt is a helper method on application type that reads a string value from the URL query
-// string and converts it to an integer before returning. If no matching key is found then it
-// returns the provided default value. If the value couldn't be converted to an integer, then we
-// record an error message in the provided Validator instance, and return the default value.
 func (app *application) readInt(qs url.Values, key string, defaultValue int, v *validator.Validator) int {
 	// Extract the value from the URL query string.
 	s := qs.Get(key)
Index: cmd/main.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/main.go b/cmd/main.go
--- a/cmd/main.go	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ b/cmd/main.go	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
@@ -9,6 +9,7 @@
 	"github.com/gorilla/mux"
 	"log"
 	"net/http"
+	"os"
 
 	_ "github.com/lib/pq"
 )
@@ -30,24 +31,28 @@
 func main() {
 	fmt.Println("Started server")
 	var cfg config
-	flag.StringVar(&cfg.port, "port", ":8081", "API server port")
+	flag.StringVar(&cfg.port, "port", ":8080", "API server port")
 	flag.StringVar(&cfg.env, "env", "development", "Environment (development|staging|production)")
 	flag.StringVar(&cfg.db.dsn, "db-dsn", "postgres://postgres:postgres@localhost:5432/gocars?sslmode=disable", "PostgreSQL DSN")
 	flag.Parse()
 
 	// Connect to DB
+	logger := jsonlog.NewLogger(os.Stdout, jsonlog.LevelInfo)
 	db, err := openDB(cfg)
 	if err != nil {
-		log.Fatal(err)
+		logger.PrintError(err, nil)
 		return
 	}
-	defer db.Close()
-
+	defer func() {
+		if err := db.Close(); err != nil {
+			logger.PrintFatal(err, nil)
+		}
+	}()
 	app := &application{
 		config: cfg,
 		models: model.NewModels(db),
+		logger: logger,
 	}
-
 	app.run()
 }
 func (app *application) run() {
@@ -56,17 +61,16 @@
 
 	v1 := r.PathPrefix("/api/v1").Subrouter()
 
-	v1.HandleFunc("/cars", app.createCarHandler).Methods("POST")
-	v1.HandleFunc("/cars/{id}", app.getCarHandler).Methods("GET")
-	v1.HandleFunc("/cars", app.getAllCarHandler).Methods("GET")
-	v1.HandleFunc("/cars/{id}", app.updateCarHandler).Methods("PUT")
-	v1.HandleFunc("/cars/{id}", app.deleteCarHandler).Methods("DELETE")
+	v1.HandleFunc("/cars", app.requirePermission("cars:write", app.createCarHandler)).Methods("POST")
+	v1.HandleFunc("/cars/:id", app.requirePermission("cars:read", app.getCarHandler)).Methods("GET")
+	v1.HandleFunc("/cars", app.requirePermission("cars:read", app.getAllCarHandler)).Methods("GET")
+	v1.HandleFunc("/cars/:id", app.requirePermission("cars:write", app.updateCarHandler)).Methods("PUT")
+	v1.HandleFunc("/cars/:id", app.requirePermission("cars:write", app.deleteCarHandler)).Methods("DELETE")
 
-	v1.HandleFunc("/owners", app.createOwnerHandler).Methods("POST")
-	v1.HandleFunc("/owners/{id}", app.getOwnerHandler).Methods("GET")
-	v1.HandleFunc("/owners", app.getAllOwnersHandler).Methods("GET")
-	v1.HandleFunc("/owners/{id}", app.updateOwnerHandler).Methods("PUT")
-	v1.HandleFunc("/owners/{id}", app.deleteOwnerHandler).Methods("DELETE")
+	v1.HandleFunc("/users", app.registerUserHandler).Methods("POST")
+	v1.HandleFunc("/users/activated", app.activateUserHandler).Methods("PUT")
+
+	v1.HandleFunc("/tokens/authentication", app.createAuthenticationTokenHandler).Methods("POST")
 
 	log.Printf("Starting server on %s\n", app.config.port)
 	err := http.ListenAndServe(app.config.port, r)
Index: cmd/userHandler.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/userHandler.go b/cmd/userHandler.go
new file mode 100644
--- /dev/null	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
+++ b/cmd/userHandler.go	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
@@ -0,0 +1,141 @@
+package main
+
+import (
+	"errors"
+	"github.com/balgabekj/go_car/pkg/model"
+	"github.com/balgabekj/go_car/pkg/validator"
+	"net/http"
+	"time"
+)
+
+func (app *application) registerUserHandler(w http.ResponseWriter, r *http.Request) {
+	// Create an anonymous struct to hold the expected model from the request body.
+	var input struct {
+		Name     string `json:"name"`
+		Email    string `json:"email"`
+		Password string `json:"password"`
+	}
+	// Parse the request body into the anonymous struct.
+	err := app.readJSON(w, r, &input)
+	if err != nil {
+		app.badRequestResponse(w, r, err)
+		return
+	}
+
+	user := &model.User{
+		Name:      input.Name,
+		Email:     input.Email,
+		Activated: false,
+	}
+
+	err = user.Password.Set(input.Password)
+	if err != nil {
+		app.serverErrorResponse(w, r, err)
+		return
+	}
+	v := validator.New()
+
+	if model.ValidateUser(v, user); !v.Valid() {
+		app.failedValidationResponse(w, r, v.Errors)
+		return
+	}
+
+	err = app.models.Users.Insert(user)
+	if err != nil {
+		switch {
+		case errors.Is(err, model.ErrDuplicateEmail):
+			v.AddError("email", "a user with this email address already exists")
+			app.failedValidationResponse(w, r, v.Errors)
+		default:
+			app.serverErrorResponse(w, r, err)
+		}
+		return
+	}
+
+	err = app.models.Permissions.AddForUser(user.ID, "cars:read")
+	if err != nil {
+		app.serverErrorResponse(w, r, err)
+		return
+	}
+
+	token, err := app.models.Tokens.New(user.ID, 3*24*time.Hour, model.ScopeActivation)
+	if err != nil {
+		app.serverErrorResponse(w, r, err)
+		return
+	}
+
+	var res struct {
+		Token *string     `json:"token"`
+		User  *model.User `json:"user"`
+	}
+
+	res.Token = &token.Plaintext
+	res.User = user
+
+	app.writeJSON(w, http.StatusCreated, envelope{"user": res}, nil)
+
+	err = app.writeJSON(w, http.StatusCreated, envelope{"user": user}, nil)
+
+	if err != nil {
+		app.serverErrorResponse(w, r, err)
+	}
+
+}
+
+func (app *application) activateUserHandler(w http.ResponseWriter, r *http.Request) {
+	// Parse the plaintext activation token from the request body.
+	var input struct {
+		TokenPlaintext string `json:"token"`
+	}
+	err := app.readJSON(w, r, &input)
+	if err != nil {
+		app.badRequestResponse(w, r, err)
+		return
+	}
+	// Validate the plaintext token provided by the client.
+	v := validator.New()
+	if model.ValidateTokenPlaintext(v, input.TokenPlaintext); !v.Valid() {
+		app.failedValidationResponse(w, r, v.Errors)
+		return
+	}
+	// Retrieve the details of the user associated with the token using the
+	// GetForToken() method (which we will create in a minute). If no matching record
+	// is found, then we let the client know that the token they provided is not valid.
+	user, err := app.models.Users.GetForToken(model.ScopeActivation, input.TokenPlaintext)
+	if err != nil {
+		switch {
+		case errors.Is(err, model.ErrRecordNotFound):
+			v.AddError("token", "invalid or expired activation token")
+			app.failedValidationResponse(w, r, v.Errors)
+		default:
+			app.serverErrorResponse(w, r, err)
+		}
+		return
+	}
+	// Update the user's activation status.
+	user.Activated = true
+	// Save the updated user record in our database, checking for any edit conflicts in
+	// the same way that we did for our movie records.
+	err = app.models.Users.Update(user)
+	if err != nil {
+		switch {
+		case errors.Is(err, model.ErrEditConflict):
+			app.editConflictResponse(w, r)
+		default:
+			app.serverErrorResponse(w, r, err)
+		}
+		return
+	}
+	// If everything went successfully, then we delete all activation tokens for the
+	// user.
+	err = app.models.Tokens.DeleteAllForUser(model.ScopeActivation, user.ID)
+	if err != nil {
+		app.serverErrorResponse(w, r, err)
+		return
+	}
+	// Send the updated user details to the client in a JSON response.
+	err = app.writeJSON(w, http.StatusOK, envelope{"user": user}, nil)
+	if err != nil {
+		app.serverErrorResponse(w, r, err)
+	}
+}
Index: go.mod
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go.mod b/go.mod
--- a/go.mod	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ b/go.mod	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
@@ -7,4 +7,6 @@
 	github.com/gorilla/mux v1.8.1 // indirect
 	github.com/julienschmidt/httprouter v1.3.0 // indirect
 	github.com/lib/pq v1.10.9 // indirect
+	golang.org/x/crypto v0.22.0 // indirect
+	golang.org/x/time v0.5.0 // indirect
 )
Index: go.sum
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/go.sum b/go.sum
--- a/go.sum	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ b/go.sum	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
@@ -6,3 +6,7 @@
 github.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=
 github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
 github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
+golang.org/x/crypto v0.22.0 h1:g1v0xeRhjcugydODzvb3mEM9SQ0HGp9s/nh3COQ/C30=
+golang.org/x/crypto v0.22.0/go.mod h1:vr6Su+7cTlO45qkww3VDJlzDn0ctJvRgYbC2NvXHt+M=
+golang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=
+golang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
Index: pkg/model/car.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/model/car.go b/pkg/model/car.go
--- a/pkg/model/car.go	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ b/pkg/model/car.go	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
@@ -9,14 +9,14 @@
 )
 
 type Car struct {
-	ID      string  `json:"id"`
-	Model   string  `json:"model"`
-	Brand   string  `json:"brand"`
-	Year    *int    `json:"year"`
-	Color   string  `json:"color"`
-	Price   float64 `json:"price"`
-	IsUsed  bool    `json:"isUsed"`
-	OwnerID string  `json:"ownerId"`
+	ID     string  `json:"id"`
+	Model  string  `json:"model"`
+	Brand  string  `json:"brand"`
+	Year   *int    `json:"year"`
+	Color  string  `json:"color"`
+	Price  float64 `json:"price"`
+	IsUsed bool    `json:"isUsed"`
+	UserID string  `json:"userId"`
 }
 
 type CarModel struct {
@@ -27,19 +27,19 @@
 
 func (m CarModel) Insert(car *Car) error {
 	query := `
-        INSERT INTO car (model, brand, year, color, price, isUsed, ownerID)
+        INSERT INTO car (model, brand, year, color, price, isUsed, userID)
         VALUES ($1, $2, $3, $4, $5, $6, $7)
         RETURNING id
     `
 	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
 	defer cancel()
 
-	return m.DB.QueryRowContext(ctx, query, car.Model, car.Brand, car.Year, car.Color, car.Price, car.IsUsed, car.OwnerID).Scan(&car.ID)
+	return m.DB.QueryRowContext(ctx, query, car.Model, car.Brand, car.Year, car.Color, car.Price, car.IsUsed, car.UserID).Scan(&car.ID)
 }
 
 func (m CarModel) Get(id string) (*Car, error) {
 	query := `
-        SELECT id, model, brand, year, color, price, isUsed, ownerID
+        SELECT id, model, brand, year, color, price, isUsed, userID
         FROM car
         WHERE id = $1
     `
@@ -50,7 +50,7 @@
 	defer cancel()
 
 	row := m.DB.QueryRowContext(ctx, query, id)
-	err := row.Scan(&car.ID, &car.Model, &car.Brand, &car.Year, &car.Color, &car.Price, &car.IsUsed, &car.OwnerID)
+	err := row.Scan(&car.ID, &car.Model, &car.Brand, &car.Year, &car.Color, &car.Price, &car.IsUsed, &car.UserID)
 	if err != nil {
 		return nil, err
 	}
@@ -59,7 +59,7 @@
 
 func (m CarModel) GetAll(brand string, minYear int, maxYear int, filters Filters) ([]Car, Metadata, error) {
 	query := fmt.Sprintf(`
-		SELECT count(*) OVER(), id,model, brand, year,color, price, isUsed, ownerId
+		SELECT count(*) OVER(), id,model, brand, year,color, price, isUsed, userId
 		FROM car
 		WHERE (LOWER(brand) = LOWER($1) OR $1 = '')
 		AND (year >= $2 OR $2 = 0)
@@ -89,7 +89,7 @@
 
 	for rows.Next() {
 		var car Car
-		err := rows.Scan(&totalRecords, &car.ID, &car.Model, &car.Brand, &car.Year, &car.Color, &car.Price, &car.IsUsed, &car.OwnerID)
+		err := rows.Scan(&totalRecords, &car.ID, &car.Model, &car.Brand, &car.Year, &car.Color, &car.Price, &car.IsUsed, &car.UserID)
 		if err != nil {
 			return nil, Metadata{}, err
 		}
Index: pkg/model/model.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/model/model.go b/pkg/model/model.go
--- a/pkg/model/model.go	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ b/pkg/model/model.go	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
@@ -2,13 +2,24 @@
 
 import (
 	"database/sql"
+	"errors"
 	"log"
 	"os"
 )
 
+var (
+	// ErrRecordNotFound is returned when a movie record doesn't exist in database.
+	ErrRecordNotFound = errors.New("record not found")
+
+	// ErrEditConflict is returned when a there is a data race, and we have an edit conflict.
+	ErrEditConflict = errors.New("edit conflict")
+)
+
 type Models struct {
-	Cars   CarModel
-	Owners OwnerModel
+	Cars        CarModel
+	Users       UserModel
+	Tokens      TokenModel
+	Permissions PermissionModel
 }
 
 func NewModels(db *sql.DB) Models {
@@ -20,7 +31,17 @@
 			InfoLog:  infoLog,
 			ErrorLog: errorLog,
 		},
-		Owners: OwnerModel{
+		Users: UserModel{
+			DB:       db,
+			InfoLog:  infoLog,
+			ErrorLog: errorLog,
+		},
+		Tokens: TokenModel{
+			DB:       db,
+			InfoLog:  infoLog,
+			ErrorLog: errorLog,
+		},
+		Permissions: PermissionModel{
 			DB:       db,
 			InfoLog:  infoLog,
 			ErrorLog: errorLog,
Index: pkg/model/user.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/model/user.go b/pkg/model/user.go
new file mode 100644
--- /dev/null	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
+++ b/pkg/model/user.go	(revision f78129c6d0a130698c3a309496dfd19dcd4c6e9c)
@@ -0,0 +1,212 @@
+package model
+
+import (
+	"context"
+	"crypto/sha256"
+	"database/sql"
+	"errors"
+	"github.com/balgabekj/go_car/pkg/validator"
+	"golang.org/x/crypto/bcrypt"
+	"log"
+	"time"
+)
+
+type User struct {
+	ID        int64     `json:"id"`
+	CreatedAt time.Time `json:"created_at"`
+	Name      string    `json:"name"`
+	Email     string    `json:"email"`
+	Password  password  `json:"-"`
+	Activated bool      `json:"activated"`
+	Version   int       `json:"-"`
+}
+
+type password struct {
+	plaintext *string
+	hash      []byte
+}
+
+var AnonymousUser = &User{}
+
+func (u *User) IsAnonymous() bool {
+	return u == AnonymousUser
+}
+
+var (
+	ErrDuplicateEmail = errors.New("duplicate email")
+)
+
+type UserModel struct {
+	DB       *sql.DB
+	InfoLog  *log.Logger
+	ErrorLog *log.Logger
+}
+
+func (p *password) Set(plaintextPassword string) error {
+	hash, err := bcrypt.GenerateFromPassword([]byte(plaintextPassword), 12)
+	if err != nil {
+		return err
+	}
+	p.plaintext = &plaintextPassword
+	p.hash = hash
+	return nil
+}
+
+func (p *password) Matches(plaintextPassword string) (bool, error) {
+	err := bcrypt.CompareHashAndPassword(p.hash, []byte(plaintextPassword))
+	if err != nil {
+		switch {
+		case errors.Is(err, bcrypt.ErrMismatchedHashAndPassword):
+			return false, nil
+		default:
+			return false, err
+		}
+	}
+	return true, nil
+}
+
+func (m UserModel) Insert(user *User) error {
+	query := `
+INSERT INTO users (name, email, password_hash, activated)
+VALUES ($1, $2, $3, $4)
+RETURNING id, created_at, version`
+	args := []interface{}{user.Name, user.Email, user.Password.hash, user.Activated}
+	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
+	defer cancel()
+	err := m.DB.QueryRowContext(ctx, query, args...).Scan(&user.ID, &user.CreatedAt, &user.Version)
+	if err != nil {
+		switch {
+		case err.Error() == `pq: duplicate key value violates unique constraint "users_email_key"`:
+			return ErrDuplicateEmail
+		default:
+			return err
+		}
+	}
+	return nil
+}
+
+func (m UserModel) GetByEmail(email string) (*User, error) {
+	query := `
+SELECT id, created_at, name, email, password_hash, activated, version
+FROM users
+WHERE email = $1`
+	var user User
+	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
+	defer cancel()
+	err := m.DB.QueryRowContext(ctx, query, email).Scan(
+		&user.ID,
+		&user.CreatedAt,
+		&user.Name,
+		&user.Email,
+		&user.Password.hash,
+		&user.Activated,
+		&user.Version,
+	)
+	if err != nil {
+		switch {
+		case errors.Is(err, sql.ErrNoRows):
+			return nil, ErrRecordNotFound
+		default:
+			return nil, err
+		}
+	}
+	return &user, nil
+}
+
+func (m UserModel) Update(user *User) error {
+	query := `
+UPDATE users
+SET name = $1, email = $2, password_hash = $3, activated = $4, version = version + 1
+WHERE id = $5 AND version = $6
+RETURNING version`
+	args := []interface{}{
+		user.Name,
+		user.Email,
+		user.Password.hash,
+		user.Activated,
+		user.ID,
+		user.Version,
+	}
+	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
+	defer cancel()
+	err := m.DB.QueryRowContext(ctx, query, args...).Scan(&user.Version)
+	if err != nil {
+		switch {
+		case err.Error() == `pq: duplicate key value violates unique constraint "users_email_key"`:
+			return ErrDuplicateEmail
+		case errors.Is(err, sql.ErrNoRows):
+			return ErrEditConflict
+		default:
+			return err
+		}
+	}
+	return nil
+}
+
+func ValidateEmail(v *validator.Validator, email string) {
+	v.Check(email != "", "email", "must be provided")
+	v.Check(validator.Matches(email, validator.EmailRX), "email", "must be a valid email address")
+}
+func ValidatePasswordPlaintext(v *validator.Validator, password string) {
+	v.Check(password != "", "password", "must be provided")
+	v.Check(len(password) >= 8, "password", "must be at least 8 bytes long")
+	v.Check(len(password) <= 72, "password", "must not be more than 72 bytes long")
+}
+func ValidateUser(v *validator.Validator, user *User) {
+	v.Check(user.Name != "", "name", "must be provided")
+	v.Check(len(user.Name) <= 500, "name", "must not be more than 500 bytes long")
+
+	ValidateEmail(v, user.Email)
+
+	if user.Password.plaintext != nil {
+		ValidatePasswordPlaintext(v, *user.Password.plaintext)
+	}
+
+	if user.Password.hash == nil {
+		panic("missing password hash for user")
+	}
+}
+
+func (m UserModel) GetForToken(tokenScope, tokenPlaintext string) (*User, error) {
+	// Calculate the SHA-256 hash of the plaintext token provided by the client.
+	// Remember that this returns a byte *array* with length 32, not a slice.
+	tokenHash := sha256.Sum256([]byte(tokenPlaintext))
+	// Set up the SQL query.
+	query := `
+	SELECT users.id, users.created_at, users.name, users.email, users.password_hash, users.activated, users.version
+	FROM users
+	INNER JOIN tokens
+	ON users.id = tokens.user_id
+	WHERE tokens.hash = $1
+	AND tokens.scope = $2
+	AND tokens.expiry > $3`
+	// Create a slice containing the query arguments. Notice how we use the [:] operator
+	// to get a slice containing the token hash, rather than passing in the array (which
+	// is not supported by the pq driver), and that we pass the current time as the
+	// value to check against the token expiry.
+	args := []interface{}{tokenHash[:], tokenScope, time.Now()}
+	var user User
+	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
+	defer cancel()
+	// Execute the query, scanning the return values into a User struct. If no matching
+	// record is found we return an ErrRecordNotFound error.
+	err := m.DB.QueryRowContext(ctx, query, args...).Scan(
+		&user.ID,
+		&user.CreatedAt,
+		&user.Name,
+		&user.Email,
+		&user.Password.hash,
+		&user.Activated,
+		&user.Version,
+	)
+	if err != nil {
+		switch {
+		case errors.Is(err, sql.ErrNoRows):
+			return nil, ErrRecordNotFound
+		default:
+			return nil, err
+		}
+	}
+	// Return the matching user.
+	return &user, nil
+}
Index: .idea/sqldialects.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/sqldialects.xml b/.idea/sqldialects.xml
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/.idea/sqldialects.xml	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="SqlDialectMappings">
+    <file url="file://$PROJECT_DIR$/pkg/migrations/000001_table.down.sql" dialect="PostgreSQL" />
+    <file url="file://$PROJECT_DIR$/pkg/migrations/000001_table.up.sql" dialect="PostgreSQL" />
+    <file url="file://$PROJECT_DIR$/pkg/migrations/000003_add_permissions.up.sql" dialect="PostgreSQL" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/sqldialects.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/sqldialects.xml b/.idea/sqldialects.xml
deleted file mode 100644
--- a/.idea/sqldialects.xml	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ /dev/null	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="SqlDialectMappings">
-    <file url="file://$PROJECT_DIR$/pkg/migrations/000001_table.down.sql" dialect="PostgreSQL" />
-    <file url="file://$PROJECT_DIR$/pkg/migrations/000001_table.up.sql" dialect="PostgreSQL" />
-  </component>
-</project>
\ No newline at end of file
Index: cmd/context.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/context.go b/cmd/context.go
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/cmd/context.go	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,33 @@
+package main
+
+import (
+	"context"
+	"net/http"
+
+	"github.com/balgabekj/go_car/pkg/model"
+)
+
+type contextKey string
+
+// userContextKey is used as a key for getting and setting user information in the request
+// context.
+const userContextKey = contextKey("user")
+
+// contextSetUser returns a new copy of the request with the provided User struct added to the
+// context.
+func (app *application) contextSetUser(r *http.Request, user *model.User) *http.Request {
+	ctx := context.WithValue(r.Context(), userContextKey, user)
+	return r.WithContext(ctx)
+}
+
+// contextGetUser retrieves the User struct from the request context. The only time that
+// this helper should be used is when we logically expect there to be a User struct value
+// in the context, and if it doesn't exist it will firmly be an 'unexpected' error, upon we panic.
+func (app *application) contextGetUser(r *http.Request) *model.User {
+	user, ok := r.Context().Value(userContextKey).(*model.User)
+	if !ok {
+		panic("missing user value in request context")
+	}
+
+	return user
+}
Index: cmd/middleware.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/middleware.go b/cmd/middleware.go
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/cmd/middleware.go	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,125 @@
+package main
+
+import (
+	"errors" // New import
+	"github.com/balgabekj/go_car/pkg/model"
+	"github.com/balgabekj/go_car/pkg/validator"
+	"net/http"
+	"strings" // New import
+)
+
+func (app *application) authenticate(next http.Handler) http.Handler {
+	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		// Add the "Vary: Authorization" header to the response. This indicates to any
+		// caches that the response may vary based on the value of the Authorization
+		// header in the request.
+		w.Header().Add("Vary", "Authorization")
+		// Retrieve the value of the Authorization header from the request. This will
+		// return the empty string "" if there is no such header found.
+		authorizationHeader := r.Header.Get("Authorization")
+		// If there is no Authorization header found, use the contextSetUser() helper
+		// that we just made to add the AnonymousUser to the request context. Then we
+		// call the next handler in the chain and return without executing any of the
+		// code below.
+		if authorizationHeader == "" {
+			r = app.contextSetUser(r, model.AnonymousUser)
+			next.ServeHTTP(w, r)
+			return
+		}
+		// Otherwise, we expect the value of the Authorization header to be in the format
+		// "Bearer <token>". We try to split this into its constituent parts, and if the
+		// header isn't in the expected format we return a 401 Unauthorized response
+		// using the invalidAuthenticationTokenResponse() helper (which we will create
+		// in a moment).
+		headerParts := strings.Split(authorizationHeader, " ")
+		if len(headerParts) != 2 || headerParts[0] != "Bearer" {
+			app.invalidAuthenticationTokenResponse(w, r)
+			return
+		}
+		// Extract the actual authentication token from the header parts.
+		token := headerParts[1]
+		// Validate the token to make sure it is in a sensible format.
+		v := validator.New()
+		// If the token isn't valid, use the invalidAuthenticationTokenResponse()
+		// helper to send a response, rather than the failedValidationResponse() helper
+		// that we'd normally use.
+		if model.ValidateTokenPlaintext(v, token); !v.Valid() {
+			app.invalidAuthenticationTokenResponse(w, r)
+			return
+		}
+		// Retrieve the details of the user associated with the authentication token,
+		// again calling the invalidAuthenticationTokenResponse() helper if no
+		// matching record was found. IMPORTANT: Notice that we are using
+		// ScopeAuthentication as the first parameter here.
+		user, err := app.models.Users.GetForToken(model.ScopeAuthentication, token)
+		if err != nil {
+			switch {
+			case errors.Is(err, model.ErrRecordNotFound):
+				app.invalidAuthenticationTokenResponse(w, r)
+			default:
+				app.serverErrorResponse(w, r, err)
+			}
+			return
+		}
+		// Call the contextSetUser() helper to add the user information to the request
+		// context.
+		r = app.contextSetUser(r, user)
+		// Call the next handler in the chain.
+		next.ServeHTTP(w, r)
+	})
+}
+
+func (app *application) requireAuthenticatedUser(next http.HandlerFunc) http.HandlerFunc {
+	return func(w http.ResponseWriter, r *http.Request) {
+		// Use the contextGetUser helper to retrieve the user information from the request context.
+		user := app.contextGetUser(r)
+
+		// If the user is anonymous, then call authenticationRequiredResponse to inform the client
+		// that they should be authenticated before trying again.
+		if user.IsAnonymous() {
+			app.authenticationRequiredResponse(w, r)
+			return
+		}
+
+		next.ServeHTTP(w, r)
+	}
+}
+
+// Checks that a user is both authenticated and activated.
+func (app *application) requireActivatedUser(next http.HandlerFunc) http.HandlerFunc {
+	// Rather than returning this http.HandlerFunc we assign it to the variable fn.
+	fn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		user := app.contextGetUser(r)
+		// Check that a user is activated.
+		if !user.Activated {
+			app.inactiveAccountResponse(w, r)
+			return
+		}
+		next.ServeHTTP(w, r)
+	})
+	// Wrap fn with the requireAuthenticatedUser() middleware before returning it.
+	return app.requireAuthenticatedUser(fn)
+}
+func (app *application) requirePermission(code string, next http.HandlerFunc) http.HandlerFunc {
+	fn := func(w http.ResponseWriter, r *http.Request) {
+		// Retrieve the user from the request context.
+		user := app.contextGetUser(r)
+		// Get the slice of permissions for the user.
+		permissions, err := app.models.Permissions.GetAllForUser(user.ID)
+		if err != nil {
+			app.serverErrorResponse(w, r, err)
+			return
+		}
+		// Check if the slice includes the required permission. If it doesn't, then
+		// return a 403 Forbidden response.
+		if !permissions.Include(code) {
+			app.notPermittedResponse(w, r)
+			return
+		}
+		// Otherwise they have the required permission so we call the next handler in
+		// the chain.
+		next.ServeHTTP(w, r)
+	}
+	// Wrap this with the requireActivatedUser() middleware before returning it.
+	return app.requireActivatedUser(fn)
+}
Index: cmd/routes.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/routes.go b/cmd/routes.go
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/cmd/routes.go	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,1 @@
+package main
Index: cmd/tokenHandlers.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/tokenHandlers.go b/cmd/tokenHandlers.go
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/cmd/tokenHandlers.go	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,69 @@
+package main
+
+import (
+	"errors"
+	"github.com/balgabekj/go_car/pkg/model"
+	"github.com/balgabekj/go_car/pkg/validator"
+	"net/http"
+	"time"
+)
+
+func (app *application) createAuthenticationTokenHandler(w http.ResponseWriter, r *http.Request) {
+	// Parse the email and password from the request body.
+	var input struct {
+		Email    string `json:"email"`
+		Password string `json:"password"`
+	}
+	err := app.readJSON(w, r, &input)
+	if err != nil {
+		app.badRequestResponse(w, r, err)
+		return
+	}
+	// Validate the email and password provided by the client.
+	v := validator.New()
+
+	model.ValidateEmail(v, input.Email)
+	model.ValidatePasswordPlaintext(v, input.Password)
+	if !v.Valid() {
+		app.failedValidationResponse(w, r, v.Errors)
+		return
+	}
+	// Lookup the user record based on the email address. If no matching user was
+	// found, then we call the app.invalidCredentialsResponse() helper to send a 401
+	// Unauthorized response to the client (we will create this helper in a moment).
+	user, err := app.models.Users.GetByEmail(input.Email)
+	if err != nil {
+		switch {
+		case errors.Is(err, model.ErrRecordNotFound):
+			app.invalidCredentialsResponse(w, r)
+		default:
+			app.serverErrorResponse(w, r, err)
+		}
+		return
+	}
+	// Check if the provided password matches the actual password for the user.
+	match, err := user.Password.Matches(input.Password)
+	if err != nil {
+		app.serverErrorResponse(w, r, err)
+		return
+	}
+	// If the passwords don't match, then we call the app.invalidCredentialsResponse()
+	// helper again and return.
+	if !match {
+		app.invalidCredentialsResponse(w, r)
+		return
+	}
+	// Otherwise, if the password is correct, we generate a new token with a 24-hour
+	// expiry time and the scope 'authentication'.
+	token, err := app.models.Tokens.New(user.ID, 24*time.Hour, model.ScopeAuthentication)
+	if err != nil {
+		app.serverErrorResponse(w, r, err)
+		return
+	}
+	// Encode the token to JSON and send it in the response along with a 201 Created
+	// status code.
+	err = app.writeJSON(w, http.StatusCreated, envelope{"authentication_token": token}, nil)
+	if err != nil {
+		app.serverErrorResponse(w, r, err)
+	}
+}
Index: pkg/migrations/000001_table.down.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/migrations/000001_table.down.sql b/pkg/migrations/000001_table.down.sql
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/pkg/migrations/000001_table.down.sql	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,2 @@
+DROP TABLE If exists car;
+DROP TABLE If exists users;
Index: pkg/migrations/000001_table.down.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/migrations/000001_table.down.sql b/pkg/migrations/000001_table.down.sql
deleted file mode 100644
--- a/pkg/migrations/000001_table.down.sql	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ /dev/null	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
@@ -1,4 +0,0 @@
-drop TABLE IF EXISTS car;
-DROP TABLE IF EXISTS owner;
-
-
Index: pkg/migrations/000001_table.up.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/migrations/000001_table.up.sql b/pkg/migrations/000001_table.up.sql
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/pkg/migrations/000001_table.up.sql	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,20 @@
+CREATE TABLE IF NOT EXISTS users (
+                                     id bigserial PRIMARY KEY,
+                                     created_at timestamp(0) with time zone NOT NULL DEFAULT NOW(),
+                                     name text NOT NULL,
+                                     email text UNIQUE NOT NULL,
+                                     password_hash bytea NOT NULL,
+                                     activated bool NOT NULL,
+                                     version integer NOT NULL DEFAULT 1
+);
+
+CREATE TABLE IF NOT EXISTS car(
+                                  id serial primary key,
+                                  model varchar,
+                                  brand varchar,
+                                  year int,
+                                  price float,
+                                  color varchar,
+                                  isUsed bool,
+                                  userId serial references users(id)
+);
Index: pkg/migrations/000001_table.up.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/migrations/000001_table.up.sql b/pkg/migrations/000001_table.up.sql
deleted file mode 100644
--- a/pkg/migrations/000001_table.up.sql	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ /dev/null	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
@@ -1,20 +0,0 @@
-CREATE TABLE IF NOT EXISTS owner(
-    id serial primary key,
-    name varchar,
-    number varchar,
-    email varchar,
-    password varchar
-);
-
-CREATE TABLE IF NOT EXISTS car(
-    id serial primary key,
-    model varchar,
-    brand varchar,
-    year int,
-    price float,
-    color varchar,
-    isUsed bool,
-    ownerId serial references owner(id)
-);
-
-
Index: pkg/migrations/000002_create_tokens_table.down.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/migrations/000002_create_tokens_table.down.sql b/pkg/migrations/000002_create_tokens_table.down.sql
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/pkg/migrations/000002_create_tokens_table.down.sql	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,1 @@
+DROP TABLE IF EXISTS tokens;
\ No newline at end of file
Index: pkg/migrations/000002_create_tokens_table.up.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/migrations/000002_create_tokens_table.up.sql b/pkg/migrations/000002_create_tokens_table.up.sql
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/pkg/migrations/000002_create_tokens_table.up.sql	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,6 @@
+CREATE TABLE IF NOT EXISTS tokens (
+                                      hash bytea PRIMARY KEY,
+                                      user_id bigint NOT NULL REFERENCES users ON DELETE CASCADE,
+                                      expiry timestamp(0) with time zone NOT NULL,
+                                                              scope text NOT NULL
+                                                              );
\ No newline at end of file
Index: pkg/migrations/000003_add_permissions.down.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/migrations/000003_add_permissions.down.sql b/pkg/migrations/000003_add_permissions.down.sql
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/pkg/migrations/000003_add_permissions.down.sql	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,2 @@
+DROP TABLE IF EXISTS users_permissions;
+DROP TABLE IF EXISTS permissions;
\ No newline at end of file
Index: pkg/migrations/000003_add_permissions.up.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/migrations/000003_add_permissions.up.sql b/pkg/migrations/000003_add_permissions.up.sql
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/pkg/migrations/000003_add_permissions.up.sql	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,16 @@
+CREATE TABLE IF NOT EXISTS permissions (
+                                           id bigserial PRIMARY KEY,
+                                           code text NOT NULL
+);
+
+CREATE TABLE IF NOT EXISTS users_permissions (
+                                                 user_id bigint NOT NULL REFERENCES users ON DELETE CASCADE,
+                                                 permission_id bigint NOT NULL REFERENCES permissions ON DELETE CASCADE,
+                                                 PRIMARY KEY (user_id, permission_id)
+);
+
+-- Insert permissions after table creation (assuming this is intended)
+INSERT INTO permissions (code)
+VALUES
+    ('cars:read'),
+    ('cars:write');
\ No newline at end of file
Index: pkg/model/permissions.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/model/permissions.go b/pkg/model/permissions.go
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/pkg/model/permissions.go	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,74 @@
+package model
+
+import (
+	"context"
+	"database/sql"
+	"github.com/lib/pq"
+	"log"
+	"time"
+)
+
+// Define a Permissions slice, which we will use to hold the permission codes (like
+// "movies:read" and "movies:write") for a single user.
+// "movies:read" and "movies:write") for a single user.
+type Permissions []string
+
+// Add a helper method to check whether the Permissions slice contains a specific
+// permission code.
+func (p Permissions) Include(code string) bool {
+	for i := range p {
+		if code == p[i] {
+			return true
+		}
+	}
+	return false
+}
+
+// Define the PermissionModel type.
+type PermissionModel struct {
+	DB       *sql.DB
+	InfoLog  *log.Logger
+	ErrorLog *log.Logger
+}
+
+// The GetAllForUser() method returns all permission codes for a specific user in a
+// Permissions slice. The code in this method should feel very familiar --- it uses the
+// standard pattern that we've already seen before for retrieving multiple data rows in
+// an SQL query.
+func (m PermissionModel) GetAllForUser(userID int64) (Permissions, error) {
+	query := `
+	SELECT permissions.code
+	FROM permissions
+	INNER JOIN users_permissions ON users_permissions.permission_id = permissions.id
+	INNER JOIN users ON users_permissions.user_id = users.id
+	WHERE users.id = $1`
+	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
+	defer cancel()
+	rows, err := m.DB.QueryContext(ctx, query, userID)
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+	var permissions Permissions
+	for rows.Next() {
+		var permission string
+		err := rows.Scan(&permission)
+		if err != nil {
+			return nil, err
+		}
+		permissions = append(permissions, permission)
+	}
+	if err = rows.Err(); err != nil {
+		return nil, err
+	}
+	return permissions, nil
+}
+func (m PermissionModel) AddForUser(userID int64, codes ...string) error {
+	query := `
+INSERT INTO users_permissions
+SELECT $1, permissions.id FROM permissions WHERE permissions.code = ANY($2)`
+	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
+	defer cancel()
+	_, err := m.DB.ExecContext(ctx, query, userID, pq.Array(codes))
+	return err
+}
Index: pkg/model/tokens.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/model/tokens.go b/pkg/model/tokens.go
new file mode 100644
--- /dev/null	(revision 9657b375d61125b62f3311224ce789806f511083)
+++ b/pkg/model/tokens.go	(revision 9657b375d61125b62f3311224ce789806f511083)
@@ -0,0 +1,89 @@
+package model
+
+import (
+	"context"
+	"crypto/rand"
+	"crypto/sha256"
+	"database/sql"
+	"encoding/base32"
+	"github.com/balgabekj/go_car/pkg/validator"
+	"log"
+	"time"
+)
+
+type Token struct {
+	Plaintext string    `json:"token"`
+	Hash      []byte    `json:"-"`
+	UserID    int64     `json:"-"`
+	Expiry    time.Time `json:"expiry"`
+	Scope     string    `json:"-"`
+}
+
+type TokenModel struct {
+	DB       *sql.DB
+	InfoLog  *log.Logger
+	ErrorLog *log.Logger
+}
+
+const (
+	ScopeActivation     = "activation"
+	ScopeAuthentication = "authentication"
+)
+
+func (m TokenModel) New(userID int64, ttl time.Duration, scope string) (*Token, error) {
+	token, err := generateToken(userID, ttl, scope)
+	if err != nil {
+		return nil, err
+	}
+	err = m.Insert(token)
+	return token, err
+}
+
+func (m TokenModel) Insert(token *Token) error {
+	query := `
+INSERT INTO tokens (hash, user_id, expiry, scope)
+VALUES ($1, $2, $3, $4)`
+	args := []interface{}{token.Hash, token.UserID, token.Expiry, token.Scope}
+	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
+	defer cancel()
+	_, err := m.DB.ExecContext(ctx, query, args...)
+	return err
+}
+
+func (m TokenModel) DeleteAllForUser(scope string, userID int64) error {
+	query := `
+		DELETE FROM tokens
+		WHERE scope = $1 AND user_id = $2
+		`
+
+	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
+	defer cancel()
+
+	_, err := m.DB.ExecContext(ctx, query, scope, userID)
+	return err
+}
+
+func generateToken(userID int64, ttl time.Duration, scope string) (*Token, error) {
+	// Create a Token instance containing the user ID, expiry, and scope information.
+	// Notice that we add the provided ttl (time-to-live) duration parameter to the
+	// current time to get the expiry time?
+	token := &Token{
+		UserID: userID,
+		Expiry: time.Now().Add(ttl),
+		Scope:  scope,
+	}
+	randomBytes := make([]byte, 16)
+	_, err := rand.Read(randomBytes)
+	if err != nil {
+		return nil, err
+	}
+	token.Plaintext = base32.StdEncoding.WithPadding(base32.NoPadding).EncodeToString(randomBytes)
+	hash := sha256.Sum256([]byte(token.Plaintext))
+	token.Hash = hash[:]
+	return token, nil
+}
+
+func ValidateTokenPlaintext(v *validator.Validator, tokenPlaintext string) {
+	v.Check(tokenPlaintext != "", "token", "must be provided")
+	v.Check(len(tokenPlaintext) == 26, "token", "must be 26 bytes long")
+}
Index: cmd/ownerHandler.go
===================================================================
diff --git a/cmd/ownerHandler.go b/cmd/ownerHandler.go
deleted file mode 100644
--- a/cmd/ownerHandler.go	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ /dev/null	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
@@ -1,105 +0,0 @@
-package main
-
-import (
-	"database/sql"
-	"encoding/json"
-	"github.com/balgabekj/go_car/pkg/model"
-	"github.com/gorilla/mux"
-	"net/http"
-)
-
-func (app *application) createOwnerHandler(w http.ResponseWriter, r *http.Request) {
-	// Extract owner data from request body
-	var owner model.Owner
-	err := app.readJSON(w, r, &owner)
-	if err != nil {
-		app.respondWithError(w, http.StatusBadRequest, "Error decoding data")
-		return
-	}
-
-	// Insert owner into the database
-	err = app.models.Owners.Insert(&owner)
-	if err != nil {
-		app.respondWithError(w, http.StatusInternalServerError, "Error creating owner")
-		return
-	}
-
-	// Return success response
-	w.WriteHeader(http.StatusCreated)
-	json.NewEncoder(w).Encode(owner)
-}
-
-func (app *application) getOwnerHandler(w http.ResponseWriter, r *http.Request) {
-	// Extract owner ID from URL parameters
-	params := mux.Vars(r)
-	id := params["id"]
-
-	// Retrieve owner from the database
-	owner, err := app.models.Owners.Get(id)
-	if err != nil {
-		if err == sql.ErrNoRows {
-			app.respondWithError(w, http.StatusNotFound, "Owner not found")
-		} else {
-			app.respondWithError(w, http.StatusInternalServerError, "Error retrieving owner")
-		}
-		return
-	}
-
-	// Return owner as JSON response
-	app.respondWithJson(w, http.StatusOK, owner)
-}
-
-func (app *application) getAllOwnersHandler(w http.ResponseWriter, r *http.Request) {
-	owners, err := app.models.Owners.GetAll()
-	if err != nil {
-		app.respondWithError(w, http.StatusInternalServerError, "Error retrieving owners")
-		return
-	}
-
-	// Return owners as JSON response
-	app.respondWithJson(w, http.StatusOK, owners)
-}
-
-func (app *application) updateOwnerHandler(w http.ResponseWriter, r *http.Request) {
-	// Extract owner ID from URL parameters
-	params := mux.Vars(r)
-	id := params["id"]
-
-	// Extract owner data from request body
-	var owner model.Owner
-	err := app.readJSON(w, r, &owner)
-	if err != nil {
-		app.respondWithError(w, http.StatusBadRequest, "Error decoding data")
-		return
-	}
-
-	// Set owner ID for update
-	owner.ID = id
-
-	// Update owner in the database
-	err = app.models.Owners.Update(&owner)
-	if err != nil {
-		app.respondWithError(w, http.StatusInternalServerError, "Error updating owner")
-		return
-	}
-
-	// Return success response
-	w.WriteHeader(http.StatusOK)
-	json.NewEncoder(w).Encode(owner)
-}
-
-func (app *application) deleteOwnerHandler(w http.ResponseWriter, r *http.Request) {
-	// Extract owner ID from URL parameters
-	params := mux.Vars(r)
-	id := params["id"]
-
-	// Delete owner from the database
-	err := app.models.Owners.Delete(id)
-	if err != nil {
-		app.respondWithError(w, http.StatusInternalServerError, "Error deleting owner")
-		return
-	}
-
-	// Return success response
-	w.WriteHeader(http.StatusNoContent)
-}
Index: pkg/model/owner.go
===================================================================
diff --git a/pkg/model/owner.go b/pkg/model/owner.go
deleted file mode 100644
--- a/pkg/model/owner.go	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
+++ /dev/null	(revision c8a53df50b02e7dab7945c099ee39a991972d46f)
@@ -1,116 +0,0 @@
-package model
-
-import (
-	"context"
-	"database/sql"
-	"log"
-	"time"
-)
-
-type Owner struct {
-	ID       string `json:"id"`
-	Name     string `json:"name"`
-	Number   string `json:"number"`
-	Email    string `json:"email"`
-	Password string `json:"password"`
-}
-
-type OwnerModel struct {
-	DB       *sql.DB
-	InfoLog  *log.Logger
-	ErrorLog *log.Logger
-}
-
-func (o OwnerModel) Insert(owner *Owner) error {
-	query := `
-        INSERT INTO owner (name, number, email, password)
-        VALUES ($1, $2, $3, $4)
-        RETURNING id
-    `
-	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
-	defer cancel()
-
-	err := o.DB.QueryRowContext(ctx, query, owner.Name, owner.Number, owner.Email, owner.Password).Scan(&owner.ID)
-	if err != nil {
-		return err
-	}
-	return nil
-}
-
-func (m OwnerModel) Get(id string) (*Owner, error) {
-	query := `
-        SELECT id, name, number, email, password
-        FROM owner
-        WHERE id = $1
-    `
-
-	var owner Owner
-
-	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
-	defer cancel()
-
-	row := m.DB.QueryRowContext(ctx, query, id)
-	err := row.Scan(&owner.ID, &owner.Name, &owner.Number, &owner.Email, &owner.Password)
-	if err != nil {
-		return nil, err
-	}
-	return &owner, nil
-}
-
-func (m OwnerModel) GetAll() ([]Owner, error) {
-	query := `
-        SELECT id, name, number, email, password
-        FROM owner
-    `
-
-	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
-	defer cancel()
-
-	rows, err := m.DB.QueryContext(ctx, query)
-	if err != nil {
-		return nil, err
-	}
-	defer rows.Close()
-
-	var owners []Owner
-	for rows.Next() {
-		var owner Owner
-		err := rows.Scan(&owner.ID, &owner.Name, &owner.Number, &owner.Email, &owner.Password)
-		if err != nil {
-			return nil, err
-		}
-		owners = append(owners, owner)
-	}
-	if err := rows.Err(); err != nil {
-		return nil, err
-	}
-
-	return owners, nil
-}
-
-func (m OwnerModel) Update(owner *Owner) error {
-	query := `
-        UPDATE owner
-        SET name = $1, number = $2, email = $3, password = $4
-        WHERE id = $5
-    `
-
-	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
-	defer cancel()
-
-	_, err := m.DB.ExecContext(ctx, query, owner.Name, owner.Number, owner.Email, owner.Password, owner.ID)
-	return err
-}
-
-func (m OwnerModel) Delete(id string) error {
-	query := `
-        DELETE FROM owner
-        WHERE id = $1
-    `
-
-	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
-	defer cancel()
-
-	_, err := m.DB.ExecContext(ctx, query, id)
-	return err
-}
